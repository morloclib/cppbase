module cppbase {

-- generic serialization functions
source Cpp from "serial.hpp" ("pack", "unpack")

-- required machinery for C++ interoperability
source Cpp from "interop.hpp" ("foreign_call")

export enumerateWith
export fold
export map
export zipWith
export add
export sub
export mul
export div
export mod

source Cpp from "core.hpp" (
  -- arithmetic
    "morloc_add" as add
  , "morloc_sub" as sub
  , "morloc_mul" as mul
  , "morloc_div" as div
  , "morloc_mod" as mod
  -- higher order functions
  , "morloc_map" as map
  , "morloc_zipWith" as zipWith
  , "morloc_fold" as fold
  , "morloc_enumerateWith" as enumerateWith
)
 
-- -- tuple functions
-- fst      :: forall a b . (a, b) -> a ;
-- snd      :: forall a b . (a, b) -> b;
-- tuple    :: forall a b . a -> b -> (a, b);
-- couple   :: forall a b . (a -> b) -> a -> (b, a);
-- with_sec :: forall a b c . (b -> c) -> (a, b) -> (a, c);
-- with_fst :: forall a b c . (a -> c) -> (a, b) -> (c, b);
-- curry    :: forall a b c . ((a, b) -> c) -> a -> b -> c;
-- uncurry  :: forall a b c . (a -> b -> c) -> (a, b) -> c;
--
-- -- pairlists
-- zip   :: forall a b . [a] -> [b] -> [(a, b)];
-- unzip :: forall a b . [(a, b)] -> ([a], [b]);
-- keys  :: forall a b . [(a, b)] -> [a];
-- vals  :: forall a b . [(a, b)] -> [b];
--
-- -- functions over pairlists
-- filter_key :: forall a b   . (a -> Bool)  -> [(a, b)] -> [(a, b)];
-- filter_val :: forall a b   . (a -> Bool)  -> [(b, a)] -> [(b, a)];
-- map_key    :: forall a b c . (a -> b)     -> [(a, c)] -> [(b, c)];
-- map_val    :: forall a b c . (a -> b)     -> [(c, a)] -> [(c, b)];
-- with_keys  :: forall a b c . ([a] -> [b]) -> [(a, c)] -> [(b, c)];
-- with_vals  :: forall a b c . ([a] -> [b]) -> [(c, a)] -> [(c, b)];
--
-- context_filter_key :: forall a b c . (a -> b -> (a, Bool)) -> a -> [(b,c)] -> [(b,c)];
-- context_filter_val :: forall a b c . (a -> b -> (a, Bool)) -> a -> [(c,b)] -> [(c,b)];
--
-- -- -- Laws
-- -- with_vals id xs == xs
-- -- with_keys id xs == xs
-- -- map_val id xs == xs
-- -- map_key id xs == xs
-- -- filter_val true xs == xs
-- -- filter_val false xs == []
-- -- filter_key true xs == xs
-- -- filter_key false xs == []
--
-- -- functional tools
-- flip :: forall a b c . (a -> b -> c) -> b -> a -> c;
-- until :: forall a . (a -> Bool) -> (a -> a) -> a -> a;
--
-- -- foldable functions - replace once I get typeclasses working
-- length :: forall a . [a] -> Int;
-- reverse :: forall a . [a] -> [a];
-- concat :: forall a . [[a]] -> [a];
-- concatMap :: forall a b . (a -> [b]) -> [a] -> [b];
--
-- -- list creation
-- replicate :: forall a . Int -> a -> [a];
--
-- -- general list processing
-- head :: forall a . [a] -> a;        -- [1,2,3] => 1
-- last :: forall a . [a] -> a;        -- [1,2,3] => 3
-- tail :: forall a . [a] -> [a];      -- [1,2,3] => [2,3]
-- init :: forall a . [a] -> [a];      -- [1,2,3] => [1,2]
-- get  :: forall a . Int -> [a] -> a; -- get 1 [1,2,3] => 2
-- take :: forall a . Int -> [a] -> [a];
-- drop :: forall a . Int -> [a] -> [a];
-- takeWhile :: forall a . (a -> Bool) -> [a] -> [a];
-- dropWhile :: forall a . (a -> Bool) -> [a] -> [a];
-- span      :: forall a . (a -> Bool) -> [a] -> ([a], [a]);
-- break     :: forall a . (a -> Bool) -> [a] -> ([a], [a]);
-- splitAt   :: forall a . Int -> [a] -> ([a], [a]);
--
-- -- string processing
-- lines   :: Str -> [Str];
-- words   :: Str -> [Str];
-- unlines :: [Str] -> Str;
-- unwords :: [Str] -> Str;
--
-- -- accumulating folds
-- scanl  :: forall a b . (b -> a -> b) -> b -> [a] -> [b];
-- scanr  :: forall a b . (a -> b -> b) -> b -> [a] -> [b];
-- scanl1 :: forall a b . (a -> a -> a) -> [a] -> [a];
-- scanr1 :: forall a b . (a -> a -> a) -> [a] -> [a];


-- NOTE: After a system for numeric casting is added to morloc, replace the
-- concrete arithmetic operators below with qualified types, e.g.:
--    add :: Num -> Num -> Num
--    add Cpp :: forall a . a -> a -> a
-- Or maybe
--    add Cpp :: forall a b c . a -> b -> c
-- So this is complicated ... if the two inputs to add can be of different
-- types, say int and double, then what is the return type? For add, the return
-- type would need to be decided based on a function of the input types. But these
-- types will depend on the function. I will need to research this problem ...
--
-- As a temporary measure, I will leave the types as "double". On the C++ side
-- in core.hpp, they are all implemented as fully generalized templates of three
-- independent types.

-- arithmetic operators - these are all
-- add :: (Num a) => forall a . a -> a -> a;
add :: Num -> Num -> Num;
add Cpp :: double -> double -> double;

-- sub :: (Num a) => forall a . a -> a -> a;
sub :: Num -> Num -> Num;
sub Cpp :: double -> double -> double;

-- mul :: (Num a) => forall a . a -> a -> a;
mul :: Num -> Num -> Num;
mul Cpp :: double -> double -> double;

-- div :: (Num a) => forall a . a -> a -> a;
div :: Num -> Num -> Num;
div Cpp :: double -> double -> double;

-- mod :: (Num a) => forall a . a -> a -> a;
div :: Num -> Num -> Num;
mod Cpp :: double -> double -> double;


map :: forall a b . (a -> b) -> [a] -> [b];
map Cpp :: forall a b . (a -> b) -> "std::vector<$1>" a
                                 -> "std::vector<$1>" b;

zipWith     :: forall a b c . (a -> b -> c) -> [a] -> [b] -> [c];
zipWith Cpp :: forall a b c . (a -> b -> c) -> "std::vector<$1>" a
                                            -> "std::vector<$1>" b
                                            -> "std::vector<$1>" c;

fold     :: forall a b . (b -> a -> b) -> b -> [a] -> b;
fold Cpp :: forall a b . (b -> a -> b) -> b -> "std::vector<$1>" a -> b;

enumerateWith     :: forall a b . (a -> Int -> b) -> [a] -> [b]; 
enumerateWith Cpp :: forall a b . (a -> "int" -> b) -> "std::vector<$1>" a
                                                    -> "std::vector<$1>" b;

}
