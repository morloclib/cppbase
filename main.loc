module cppbase

import conventions

type Cpp Real = "double"
type Cpp Int = "int"
type Cpp Str = "std::string"
type Cpp Bool = "bool"

export Map
export Real
export Int
export Str
export Bool

export id
export at
export enumerateWith
export fold
export map
export zipWith
export add
export sub
export mul
export div
export neg
export mod

export zip
export unzip
export keys
export vals
export filterKey
export filterVal
export mapKey
export mapVal
export withKeys
export withVals

export eq
export filter
export gt
export head
export ifelse
export length
export unique

source Cpp from "core.hpp"
 (
   "morloc_id" as id
 -- arithmetic
 , "morloc_add" as add
 , "morloc_sub" as sub
 , "morloc_mul" as mul
 , "morloc_div" as div
 , "morloc_neg" as neg
 , "morloc_mod" as mod
 -- higher order functions
 , "morloc_at" as at
 , "morloc_map" as map
 , "morloc_zipWith" as zipWith
 , "morloc_fold" as fold
 , "morloc_enumerateWith" as enumerateWith
 -- pair-list functions
 , "morloc_zip" as zip
 , "morloc_unzip" as unzip
 , "morloc_keys" as keys
 , "morloc_vals" as vals
 , "morloc_filter_key" as filterKey
 , "morloc_filter_val" as filterVal
 , "morloc_map_key" as mapKey
 , "morloc_map_val" as mapVal
 , "morloc_with_keys" as withKeys
 , "morloc_with_vals" as withVals
 -- new functions for the paper case study
 , "morloc_unique" as unique
 , "morloc_ifelse" as ifelse
 , "morloc_eq" as eq
 , "morloc_head" as head
 , "morloc_filter" as filter
 , "morloc_gt" as gt
 , "morloc_length" as length
 )

id Cpp :: a -> a

-- arithmetic operators - these are all
-- add :: (Real a) => a -> a -> a
add Cpp :: "double" -> "double" -> "double"

-- sub :: (Real a) => a -> a -> a
sub Cpp :: "double" -> "double" -> "double"

-- mul :: (Real a) => a -> a -> a
mul Cpp :: "double" -> "double" -> "double"

-- div :: (Real a) => a -> a -> a
div Cpp :: "double" -> "double" -> "double"

neg Cpp :: "double" -> "double"

-- mod :: (Real a) => a -> a -> a
mod Cpp :: "double" -> "double" -> "double"


at Cpp :: "int" -> "std::vector<$1>" a -> a

map Cpp :: (a -> b) -> "std::vector<$1>" a
                    -> "std::vector<$1>" b

zipWith Cpp :: (a -> b -> c) -> "std::vector<$1>" a
                             -> "std::vector<$1>" b
                             -> "std::vector<$1>" c

fold Cpp :: (b -> a -> b) -> b -> "std::vector<$1>" a -> b

enumerateWith Cpp :: (a -> "int" -> b) -> "std::vector<$1>" a
                                       -> "std::vector<$1>" b


-------------------------------------------------------------------------------
--                       Pair-list functions
-------------------------------------------------------------------------------



-- pairlists
zip   Cpp :: [a] -> [b] -> [(a, b)]
unzip Cpp :: [(a, b)] -> ([a], [b])
keys  Cpp :: [(a, b)] -> [a]
vals  Cpp :: [(a, b)] -> [b]

-- functions over pairlists
filterKey Cpp :: (a -> Bool)  -> [(a, b)] -> [(a, b)]
filterVal Cpp :: (a -> Bool)  -> [(b, a)] -> [(b, a)]
mapKey    Cpp :: (a -> b)     -> [(a, c)] -> [(b, c)]
mapVal    Cpp :: (a -> b)     -> [(c, a)] -> [(c, b)]
withKeys  Cpp :: ([a] -> [b]) -> [(a, c)] -> [(b, c)]
withVals  Cpp :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]



-- functions added for case study (reorganize these later)
unique Cpp :: [a] -> [a]
ifelse Cpp :: Bool -> a -> a
length :: [a] -> Int
head :: [a] -> a
filter :: (a -> Bool) -> [a] -> [a]

-- generalize when typeclasses become available
-- should be:
--    eq :: (Ord a) => a -> a -> Bool
eq :: Int -> Int -> Bool
gt :: Int -> Int -> Bool

-------------------------------------------------------------------------------
--                 Pack and Unpack internal functions
-- These functions are used by morloc internally for (de)serialization of types
-- that cannot be automatically (de)serialized into/from JSON. They should not
-- be exported.
-------------------------------------------------------------------------------

source Cpp from "data.hpp"
 ( "morloc_packMap" as packMap
 , "morloc_unpackMap" as unpackMap
 )


type Cpp (Map key val) = "std::map<$1,$2>" key val

-- These do not need to be exported (and indeed should not be)
packMap :: pack => ([key],[val]) -> Map key val
packMap Cpp :: pack => ([key],[val]) -> "std::map<$1,$2>" key val

unpackMap :: unpack => Map key val -> ([key],[val])
unpackMap Cpp :: unpack => "std::map<$1,$2>" key val -> ([key],[val])
