source "Cpp" from "core.hpp" (
    "map"
  , "zipWith"
  , "fold"
  , "enumerateWith"
)

map :: (a -> b), [a] -> b;
zipWith :: (a, b -> c), [a], [b] -> [c];
fold :: (b, a -> b), b, [a] -> b;
enumerateWith :: (a, Int -> b), [a] -> [b];

source "Cpp" from "serializers.hpp" (
    "packDouble"
  , "unpackDouble"
  , "packInt"
  , "unpackInt"
  , "packSizeT"
  , "unpackSizeT"
  , "packString"
  , "unpackString"
  # hard-coded vectors (I need a generic way to handle these)
  , "packDoubles"
  , "unpackDoubles"
  , "packInts"
  , "unpackInts"
  , "packSizeTs"
  , "unpackSizeTs"
  , "packStrings"
  , "unpackStrings"
)

# JSON input is char*, but the serialized results are std::string

packDouble Cpp :: packs => "double" -> "std::string";

unpackDouble Cpp :: unpacks => "char*" -> "double";

packInt Cpp :: packs => "int" -> "std::string";
unpackInt Cpp :: unpacks => "char*" -> "int";

packSizeT Cpp :: packs => "size_t" -> "std::string";
unpackSizeT Cpp :: unpacks => "char*" -> "size_t";

packString Cpp :: packs => "std::string" -> "std::string";
unpackString Cpp :: unpacks => "char*" -> "std::string";

packInts Cpp :: packs => "std::vector<int>" -> "std::string";
unpackInts Cpp :: unpacks => "std::string" -> "std::vector<int>";

packSizeTs Cpp :: packs => "std::vector<size_t>" -> "std::string";
unpackSizeTs Cpp :: unpacks => "std::string" -> "std::vector<size_t>";

packDoubles Cpp :: packs => "std::vector<double>" -> "std::string";
unpackDoubles Cpp :: unpacks => "std::string" -> "std::vector<double>";

packStrings Cpp :: packs => "std::vector<string>" -> "std::string";
unpackStrings Cpp :: unpacks => "std::string" -> "std::vector<string>";
