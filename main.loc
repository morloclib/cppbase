module cppbase {

-- generic serialization functions
source Cpp from "serial.hpp" ("pack", "unpack")

-- required machinery for C++ interoperability
source Cpp from "interop.hpp" ("foreign_call")

export enumerateWith
export fold
export map
export zipWith
export add
export sub
export mul
export div
export mod

source Cpp from "core.hpp" (
  -- arithmetic
    "morloc_add" as add
  , "morloc_sub" as sub
  , "morloc_mul" as mul
  , "morloc_div" as div
  , "morloc_mod" as mod
  -- higher order functions
  , "morloc_map" as map
  , "morloc_zipWith" as zipWith
  , "morloc_fold" as fold
  , "morloc_enumerateWith" as enumerateWith
)

-- NOTE: After a system for numeric casting is added to morloc, replace the
-- concrete arithmetic operators below with qualified types, e.g.:
--    add :: Num -> Num -> Num
--    add Cpp :: forall a . a -> a -> a
-- Or maybe
--    add Cpp :: forall a b c . a -> b -> c
-- So this is complicated ... if the two inputs to add can be of different
-- types, say int and double, then what is the return type? For add, the return
-- type would need to be decided based on a function of the input types. But these
-- types will depend on the function. I will need to research this problem ...
--
-- As a temporary measure, I will leave the types as "double". On the C++ side
-- in core.hpp, they are all implemented as fully generalized templates of three
-- independent types.

-- arithmetic operators - these are all
-- add :: (Num a) => forall a . a -> a -> a;
add :: Num -> Num -> Num;
add Cpp :: double -> double -> double;

-- sub :: (Num a) => forall a . a -> a -> a;
sub :: Num -> Num -> Num;
sub Cpp :: double -> double -> double;

-- mul :: (Num a) => forall a . a -> a -> a;
mul :: Num -> Num -> Num;
mul Cpp :: double -> double -> double;

-- div :: (Num a) => forall a . a -> a -> a;
div :: Num -> Num -> Num;
div Cpp :: double -> double -> double;

-- mod :: (Num a) => forall a . a -> a -> a;
div :: Num -> Num -> Num;
mod Cpp :: double -> double -> double;


map :: forall a b . (a -> b) -> [a] -> [b];
map Cpp :: forall a b . (a -> b) -> "std::vector<$1>" a
                                 -> "std::vector<$1>" b;

zipWith     :: forall a b c . (a -> b -> c) -> [a] -> [b] -> [c];
zipWith Cpp :: forall a b c . (a -> b -> c) -> "std::vector<$1>" a
                                            -> "std::vector<$1>" b
                                            -> "std::vector<$1>" c;

fold     :: forall a b . (b -> a -> b) -> b -> [a] -> b;
fold Cpp :: forall a b . (b -> a -> b) -> b -> "std::vector<$1>" a -> b;

enumerateWith     :: forall a b . (a -> Int -> b) -> [a] -> [b]; 
enumerateWith Cpp :: forall a b . (a -> "int" -> b) -> "std::vector<$1>" a
                                                    -> "std::vector<$1>" b;

}
